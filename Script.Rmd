---
title: "Assignment 3: parallel computing "
author: "Stijn Hanssen"
date: "Oktober 2018"
output: html_document
---

### Clear working space
First step is to make sure that the working space is empty.
```{r}
# clear all variables
rm(list=ls()) 
```

### Set path working directory
The directory path is set to the stored datasets.
```{r}
# set working directory
setwd("C:/Users/stijn/Desktop/Master systems biology/Systems biology year 2/scientific computing/parallelprocessing") 
```

### Load libraries
Loading the required packages for specific functions. 
```{r}
# setting working memory for this job to 8gb
options(java.parameters = "-Xmx8g")
# install pacman
if (!require("pacman")) suppressPackageStartupMessages(install.packages("pacman"))
# p_load: instal and load the packages
# ittertools: for proper nextElem support
# rcdk: acces functioality of jave framework
# doParallel: provides parallel backend for the dopar function
pacman::p_load("parallel","rcdk","itertools","doParallel")
```

### Import data

```{r}
# total amount molecules in sdf file
max_n_molecules = 377550
# amount molecules imported
n = 1000
# iload.molecules: iterating version of loader
iter <- iload.molecules('C:/Users/stijn/Desktop/Master systems biology/Systems biology year 2/scientific computing/parallelprocessing/aid624202.sdf', type='sdf')
# text progress bar
pb <- txtProgressBar(min = 0, max = n , style = 3)
# initiate value
step = 0 
# set a list
mols = list()
# while loop to iterate until n is reached
while(hasNext(iter)) {
step = step + 1
# generic function to prodcue values, save values in mols    
    mols[[step]] <- nextElem(iter)
setTxtProgressBar(pb,step)
if(step == n){
    break
  }
}
close(pb)
```

### list descriptors

```{r}
# list of descriptors wanted to calculate
descNames <- unique(unlist(sapply(get.desc.categories()[2:4], get.desc.names)))
```

### Convert into smiles

```{r}
# produce vector containing the atomic components
mols = unlist(mols)
# function generate smiels representation of IAtomContainer object
smiles = lapply(mols,get.smiles)
```

### Parallel version lapply: foreach 3 cores

```{r}
# set total amount of cores that can be used
nCores <- detectCores() - 1
# set copies to run in parallel and communicate over the sockets
cl <- makeCluster(nCores)     
# clusterExport: that all cores in cluster have the variable available
clusterExport(cl,"descNames") 
clusterExport(cl,"smiles")
# distribute the packages to each core
clusterEvalQ(cl, pacman::p_load("parallel","rcdk","itertools","doParallel"))
# make the process parallel
registerDoParallel(cl)

system.time(foreach(i=1:n,.combine=rbind) %dopar% eval.desc(parse.smiles(smiles[[i]]),descNames,verbose=F))[3]    
 
stopImplicitCluster()

```

### Parallel version lapply: foreach 2 cores

```{r}
# set total amount of cores that can be used
nCores <- detectCores() - 2
# set copies to run in parallel and communicate over the sockets
cl <- makeCluster(nCores)     
# clusterExport: that all cores in cluster have the variable available
clusterExport(cl,"descNames") 
clusterExport(cl,"smiles")
# distribute the packages to each core
clusterEvalQ(cl, pacman::p_load("parallel","rcdk","itertools","doParallel"))
# make the process parallel
registerDoParallel(cl)

system.time(foreach(i=1:n,.combine=rbind) %dopar% eval.desc(parse.smiles(smiles[[i]]),descNames,verbose=F))[3]    
 
stopImplicitCluster()

```

### Test: arallel version lapply: parLapply

```{r}
# set total amount of cores that can be used
nCores <- detectCores() - 1
# set copies to run in parallel and communicate over the sockets
cl <- makeCluster(nCores)     
# clusterExport: that all cores in cluster have the variable available
clusterExport(cl,"descNames") 
clusterExport(cl,"smiles")
# distribute the packages to each core
clusterEvalQ(cl, pacman::p_load("parallel","rcdk","itertools","doParallel"))
# make the process parallel
x = function(i) {eval.desc(parse.smiles(smiles[[i]]),descNames,verbose=F)[3] }
system.time(parLapply(cl,seq_len(smiles),x))
stopCluster(cl)
```
